using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Ateleris.NET.Generators;

public readonly record struct EnumUtilInfo(string EnumName, string EnumNamespace, List<(string Name, int Value)> EnumMembers);

[Generator]
public class EnumUtilGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<EnumUtilInfo?> enums = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetEnumInfo(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(enums, static (spc, source) => Execute(source, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        => node is EnumDeclarationSyntax m && m.AttributeLists.Count > 0;

    private static EnumUtilInfo? GetEnumInfo(GeneratorSyntaxContext context)
    {
        if (context.Node is not EnumDeclarationSyntax enumDeclaration) return null;

        var semanticModel = context.SemanticModel;
        if (semanticModel.GetDeclaredSymbol(enumDeclaration) is not INamedTypeSymbol enumSymbol) return null;

        var attributeData = enumSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "Shared.Attributes.GenerateEnumUtilsAttribute");

        if (attributeData is null) return null;

        var members = new List<(string Name, int Value)>();
        foreach (var member in enumSymbol.GetMembers().OfType<IFieldSymbol>())
        {
            if (member.ConstantValue is int value)
            {
                members.Add((member.Name, value));
            }
        }

        return new EnumUtilInfo(
            enumSymbol.Name,
            enumSymbol.ContainingNamespace.ToDisplayString(),
            members);
    }

    private static void Execute(EnumUtilInfo? enumInfo, SourceProductionContext context)
    {
        if (enumInfo is { } info)
        {
            string result = GenerateEnumUtils(info);
            context.AddSource($"{info.EnumName}Utils.g.cs", SourceText.From(result, Encoding.UTF8));
        }
    }

    private static string GenerateEnumUtils(EnumUtilInfo info)
    {
        var sb = new StringBuilder();
        sb.AppendLine($@"// <auto-generated/>
using System;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace {info.EnumNamespace};

public static class {info.EnumName}Utils
{{
    public static {info.EnumName} FromString(string value) =>
        value.ToUpper() switch
        {{");

        foreach (var (name, _) in info.EnumMembers)
        {
            sb.AppendLine($@"            ""{name}"" => {info.EnumName}.{name},");
        }

        sb.AppendLine($@"            _ => throw new ArgumentOutOfRangeException(nameof(value))
        }};

    public static string ToString({info.EnumName} value) =>
        value switch
        {{");

        foreach (var (name, _) in info.EnumMembers)
        {
            sb.AppendLine($@"            {info.EnumName}.{name} => ""{name}"",");
        }

        sb.AppendLine($@"            _ => throw new ArgumentOutOfRangeException(nameof(value))
        }};
}}

public class {info.EnumName}Converter : JsonConverter<{info.EnumName}>
{{
    public override {info.EnumName} Read(
        ref Utf8JsonReader reader,
        Type typeToConvert,
        JsonSerializerOptions options) => {info.EnumName}Utils.FromString(reader.GetString() ?? string.Empty);

    public override void Write(
        Utf8JsonWriter writer,
        {info.EnumName} value,
        JsonSerializerOptions options) => writer.WriteStringValue({info.EnumName}Utils.ToString(value));
}}");

        return sb.ToString();
    }
}
